# Backend ‚Äì FastAPI + SQLModel + Neon PostgreSQL

**Phase II Full-Stack Web Application Backend ‚Äì Spec F01-S01**

This is the backend REST API for the Evolution of Todo Phase II project, built with FastAPI, SQLModel ORM, and Neon Serverless PostgreSQL.

> **Note**: This implementation includes both F01-S01 (Backend API & Database) and F01-S02 (Authentication & Security). JWT-based authentication is fully implemented.

---

## Table of Contents

- [Overview](#overview)
- [Technology Stack](#technology-stack)
- [Quick Start](#quick-start)
- [API Endpoints](#api-endpoints)
- [Project Structure](#project-structure)
- [Configuration](#configuration)
- [Testing](#testing)

---

## Overview

The backend provides:

- **RESTful API** endpoints for task CRUD operations
- **JWT-based authentication** with user identity extracted from verified tokens
- **User-scoped data access** (each user can only access their own tasks)
- **Input validation** with Pydantic models
- **PostgreSQL persistence** via Neon Serverless
- **OpenAPI documentation** (auto-generated by FastAPI)

---

## Technology Stack

| Component | Technology | Version | Purpose |
|-----------|-----------|---------|---------|
| Framework | **FastAPI** | 0.109.0 | High-performance web framework |
| ORM | **SQLModel** | 0.0.14 | Type-safe database operations |
| Database | **Neon PostgreSQL** | Serverless | Managed PostgreSQL |
| Validation | **Pydantic** | 2.5.0 | Request/response validation |
| Server | **uvicorn** | 0.27.0 | ASGI server |

---

## Quick Start

```bash
# 1. Navigate to backend directory
cd backend

# 2. Create virtual environment
python -m venv venv

# 3. Activate virtual environment
# Windows:
venv\Scripts\activate
# macOS/Linux:
source venv/bin/activate

# 4. Install dependencies
pip install -r requirements.txt

# 5. Configure environment
cp config/.env.example .env
# Edit .env with your Neon PostgreSQL connection string:
# DATABASE_URL=postgresql://user:password@host/database?sslmode=require

# 6. Run the server
uvicorn src.main:app --reload --host 0.0.0.0 --port 8000
```

**API Documentation**: http://localhost:8000/docs

---

## API Endpoints

All task endpoints require JWT authentication via `Authorization: Bearer <token>` header. User identity is extracted from the verified JWT token.

### Task CRUD Operations

| Method | Endpoint | Description | Status |
|--------|----------|-------------|--------|
| POST | `/api/tasks` | Create task | 201 |
| GET | `/api/tasks` | List user's tasks | 200 |
| GET | `/api/tasks/{id}` | Get task by ID | 200/403/404 |
| PATCH | `/api/tasks/{id}` | Update task | 200/403/404 |
| DELETE | `/api/tasks/{id}` | Delete task | 204/403/404 |

### Example Requests

```bash
# First, login to get a JWT token
TOKEN=$(curl -s -X POST "http://localhost:8000/auth/login" \
  -H "Content-Type: application/json" \
  -d '{"email": "user@example.com", "password": "password123"}' | jq -r '.token')

# Create a task
curl -X POST "http://localhost:8000/api/tasks" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"title": "Buy groceries", "priority": "high", "tags": ["shopping"]}'

# List tasks
curl "http://localhost:8000/api/tasks" \
  -H "Authorization: Bearer $TOKEN"

# List with filters
curl "http://localhost:8000/api/tasks?status=todo&priority=high" \
  -H "Authorization: Bearer $TOKEN"

# Update task
curl -X PATCH "http://localhost:8000/api/tasks/{task_id}" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"status": "completed"}'

# Delete task
curl -X DELETE "http://localhost:8000/api/tasks/{task_id}" \
  -H "Authorization: Bearer $TOKEN"
```

### Error Responses

```json
{
  "error": {
    "code": 401,
    "message": "Invalid or expired token"
  }
}
```

| Code | Meaning |
|------|---------|
| 400 | Bad Request (validation error) |
| 401 | Unauthorized (missing or invalid JWT) |
| 403 | Forbidden (cross-user access attempt) |
| 404 | Not Found (task doesn't exist) |
| 500 | Internal Server Error |

---

## Features

### 1. RESTful API

- Resource-oriented endpoints (`/api/tasks`, `/api/tasks/{id}`)
- Proper HTTP methods (GET, POST, PATCH, DELETE)
- Appropriate status codes (200, 201, 400, 401, 403, 404, 500)
- JSON request/response format

### 2. JWT Authentication

- Verifies JWT tokens issued by Better Auth (frontend)
- Extracts `user_id` from verified token claims
- Returns 401 for missing/invalid tokens
- Stateless authentication (no server-side sessions)

### 3. User-Scoped Data

- **ALL database queries filtered by authenticated `user_id`**
- Users can ONLY access their own tasks
- Cross-user access returns 403 Forbidden
- User ownership enforced at service layer

### 4. Input Validation

- Pydantic models for request bodies
- Type checking and constraint validation
- Clear error messages for validation failures
- SQL injection prevention (parameterized queries)

### 5. Database Migrations

- Alembic for schema version control
- Reversible migrations
- Safe schema evolution

---

## Project Structure

```
backend/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.py                       # FastAPI app entry point
‚îÇ   ‚îú‚îÄ‚îÄ config.py                     # Configuration (env vars)
‚îÇ   ‚îú‚îÄ‚îÄ database.py                   # Database connection & session
‚îÇ   ‚îú‚îÄ‚îÄ auth/                         # Authentication module
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ jwt_middleware.py         # JWT verification
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes.py                 # /auth/signup, /auth/login
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models.py                 # User SQLModel
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ schemas.py                # UserSignup, UserLogin Pydantic models
‚îÇ   ‚îú‚îÄ‚îÄ tasks/                        # Task CRUD module
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes.py                 # /api/tasks endpoints
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models.py                 # Task SQLModel
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ schemas.py                # TaskCreate, TaskUpdate Pydantic models
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ service.py                # Business logic
‚îÇ   ‚îî‚îÄ‚îÄ common/                       # Shared utilities
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ exceptions.py             # Custom exceptions
‚îÇ       ‚îî‚îÄ‚îÄ dependencies.py           # Common dependencies
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ conftest.py                   # Pytest fixtures
‚îÇ   ‚îú‚îÄ‚îÄ test_auth.py                  # Auth endpoint tests
‚îÇ   ‚îî‚îÄ‚îÄ test_tasks.py                 # Task endpoint tests
‚îú‚îÄ‚îÄ alembic/                          # Database migrations
‚îÇ   ‚îú‚îÄ‚îÄ versions/                     # Migration scripts
‚îÇ   ‚îî‚îÄ‚îÄ env.py
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ .env.example
‚îú‚îÄ‚îÄ alembic.ini
‚îî‚îÄ‚îÄ README.md                         # This file
```

---

## Setup

### Prerequisites

- **Python** 3.12 or higher
- **pip** (Python package manager)
- **PostgreSQL** (Neon account recommended)

### 1. Clone Repository

```bash
cd backend
```

### 2. Create Virtual Environment

```bash
python -m venv venv

# Activate (Windows)
venv\Scripts\activate

# Activate (macOS/Linux)
source venv/bin/activate
```

### 3. Install Dependencies

```bash
pip install -r requirements.txt
```

---

## Configuration

### Environment Variables

Copy the example environment file and configure:

```bash
cp .env.example .env
```

Edit `.env`:

```ini
# Database Configuration
DATABASE_URL=postgresql://user:password@host/database?sslmode=require

# JWT Configuration (MUST match Better Auth secret on frontend)
JWT_SECRET=your-super-secret-key-minimum-32-characters-long-and-random
JWT_ALGORITHM=HS256

# Application Configuration
ENVIRONMENT=development
DEBUG=True
API_HOST=0.0.0.0
API_PORT=8000

# CORS (Frontend URL)
CORS_ORIGINS=http://localhost:3000,https://your-frontend-domain.vercel.app
```

**IMPORTANT**:
- `JWT_SECRET` MUST match the secret used by Better Auth on the frontend
- NEVER commit `.env` to version control (already in `.gitignore`)
- Use a strong, random secret for `JWT_SECRET` (minimum 32 characters)

### Neon PostgreSQL Setup

1. Create account at [Neon](https://neon.tech/)
2. Create a new project
3. Copy the connection string
4. Paste into `.env` as `DATABASE_URL`

---

## Running the Application

### Development Mode

```bash
# Run with auto-reload
uvicorn src.main:app --reload --host 0.0.0.0 --port 8000
```

### Production Mode

```bash
# Run with gunicorn (multiple workers)
gunicorn src.main:app --workers 4 --worker-class uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000
```

### Access API

- **API Base URL**: http://localhost:8000
- **OpenAPI Docs**: http://localhost:8000/docs
- **ReDoc**: http://localhost:8000/redoc

---

## API Documentation

### Authentication Endpoints

#### POST /auth/signup

Register a new user.

**Request:**
```json
{
  "email": "user@example.com",
  "password": "securepassword123"
}
```

**Response (201 Created):**
```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "user_id": "550e8400-e29b-41d4-a716-446655440000",
  "email": "user@example.com"
}
```

#### POST /auth/login

Authenticate existing user.

**Request:**
```json
{
  "email": "user@example.com",
  "password": "securepassword123"
}
```

**Response (200 OK):**
```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "user_id": "550e8400-e29b-41d4-a716-446655440000",
  "email": "user@example.com"
}
```

### Task Endpoints

**ALL task endpoints require JWT authentication via `Authorization: Bearer <token>` header.**

#### GET /api/tasks

List all tasks for authenticated user.

**Headers:**
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Response (200 OK):**
```json
[
  {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "user_id": "7c9e6679-7425-40de-944b-e07fc1f90ae7",
    "title": "Complete authentication",
    "description": "Implement JWT-based auth",
    "status": "in-progress",
    "priority": "high",
    "tags": ["phase-ii", "security"],
    "created_at": "2026-01-09T10:30:00Z",
    "updated_at": "2026-01-09T10:30:00Z"
  }
]
```

#### POST /api/tasks

Create a new task for authenticated user.

**Headers:**
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Request:**
```json
{
  "title": "Complete authentication",
  "description": "Implement JWT-based auth",
  "status": "todo",
  "priority": "high",
  "tags": ["phase-ii", "security"]
}
```

**Response (201 Created):**
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "user_id": "7c9e6679-7425-40de-944b-e07fc1f90ae7",
  "title": "Complete authentication",
  "description": "Implement JWT-based auth",
  "status": "todo",
  "priority": "high",
  "tags": ["phase-ii", "security"],
  "created_at": "2026-01-09T10:30:00Z",
  "updated_at": "2026-01-09T10:30:00Z"
}
```

#### GET /api/tasks/{id}

Get a specific task by ID (must be owned by authenticated user).

**Headers:**
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Response (200 OK):** Same as POST response
**Response (403 Forbidden):** If task not owned by user
**Response (404 Not Found):** If task doesn't exist

#### PATCH /api/tasks/{id}

Update a task (must be owned by authenticated user).

**Headers:**
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Request:**
```json
{
  "status": "completed"
}
```

**Response (200 OK):** Updated task object

#### DELETE /api/tasks/{id}

Delete a task (must be owned by authenticated user).

**Headers:**
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Response (204 No Content)**

### Error Responses

All errors return JSON:

```json
{
  "error": {
    "code": 401,
    "message": "Token expired"
  }
}
```

**Status Codes:**
- 400: Bad Request (validation failure)
- 401: Unauthorized (missing/invalid JWT)
- 403: Forbidden (cross-user access attempt)
- 404: Not Found
- 422: Unprocessable Entity (business logic violation)
- 500: Internal Server Error

---

## Authentication

### JWT Verification Flow

1. Frontend includes JWT in `Authorization: Bearer <token>` header
2. Backend middleware extracts token from header
3. Backend verifies JWT signature using shared secret
4. Backend decodes token to extract `user_id` claim
5. Backend attaches `user_id` to request context
6. Endpoint handler uses `user_id` for database queries

### Critical Security Rules

‚úÖ **DO**:
- Verify JWT signature on every request
- Extract `user_id` from verified token
- Filter ALL database queries by `user_id`
- Return 403 for cross-user access attempts
- Store JWT secret in environment variables

‚ùå **DON'T**:
- Trust client-provided `user_id` (ALWAYS extract from JWT)
- Allow queries without user filtering
- Expose JWT secret in source code
- Return 404 for unauthorized resources (information leak)

### Example JWT Verification

```python
# src/auth/jwt_middleware.py
from fastapi import Depends, HTTPException
from fastapi.security import HTTPBearer
import jwt

security = HTTPBearer()

async def verify_jwt(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """Verify JWT and extract user_id."""
    token = credentials.credentials

    try:
        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])
        user_id = payload.get("user_id")

        if not user_id:
            raise HTTPException(status_code=401, detail="Invalid token")

        return user_id

    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token expired")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="Invalid token")
```

### User-Scoped Queries

```python
# src/tasks/routes.py
@router.get("/")
async def list_tasks(
    user_id: str = Depends(verify_jwt),  # ‚Üê JWT verification
    db: Session = Depends(get_db)
):
    """List tasks for authenticated user ONLY."""
    tasks = db.query(Task).filter(Task.user_id == user_id).all()
    return tasks
```

---

## Database

### Migrations with Alembic

#### Create Migration

```bash
alembic revision --autogenerate -m "Add tasks table"
```

#### Apply Migrations

```bash
alembic upgrade head
```

#### Rollback Migration

```bash
alembic downgrade -1
```

### Database Schema

```sql
-- Users table
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    hashed_password VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Tasks table
CREATE TABLE tasks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    status VARCHAR(50) NOT NULL DEFAULT 'todo',
    priority VARCHAR(50),
    tags TEXT[],
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_tasks_user_id ON tasks(user_id);
CREATE INDEX idx_tasks_status ON tasks(status);
CREATE INDEX idx_users_email ON users(email);
```

---

## Testing

### Run Tests

```bash
# Run all tests
pytest

# Run with coverage
pytest --cov=src --cov-report=html

# Run specific test file
pytest tests/test_auth.py

# Run with verbose output
pytest -v
```

### Test Categories

1. **Unit Tests**: Business logic in services
2. **Integration Tests**: API endpoints with database
3. **Auth Tests**: JWT verification, login, signup
4. **Authorization Tests**: User-scoped access, 403 errors

---

## Deployment

### Railway Deployment

1. Create Railway account
2. Create new project
3. Add Neon PostgreSQL plugin
4. Deploy from GitHub
5. Configure environment variables
6. Run migrations: `railway run alembic upgrade head`

### Render Deployment

1. Create Render account
2. Create new Web Service
3. Connect GitHub repository
4. Configure build command: `pip install -r requirements.txt`
5. Configure start command: `gunicorn src.main:app --workers 4 --worker-class uvicorn.workers.UvicornWorker --bind 0.0.0.0:$PORT`
6. Add environment variables
7. Add Neon PostgreSQL connection string
8. Deploy

---

## References

- **FastAPI Documentation**: https://fastapi.tiangolo.com/
- **SQLModel Documentation**: https://sqlmodel.tiangolo.com/
- **Neon Documentation**: https://neon.tech/docs
- **Alembic Documentation**: https://alembic.sqlalchemy.org/
- **JWT.io**: https://jwt.io/

---

**Built with FastAPI, SQLModel, and Neon PostgreSQL** üöÄ
